<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>leetcode算法(一)</title>
    <url>/2020/09/18/leetcode%E7%AE%97%E6%B3%95-%E4%B8%80/</url>
    <content><![CDATA[<h1 id="剑指offer03：数组中重复的数字"><a href="#剑指offer03：数组中重复的数字" class="headerlink" title="剑指offer03：数组中重复的数字"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/" target="_blank" rel="noopener">剑指offer03：数组中重复的数字</a></h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在一个长度为 n 的数组 nums 里的所有数字都在 <strong>0～n-1</strong> 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p>
<p>限制 : 2 &lt;= n &lt;= 100000</p>
<a id="more"></a>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ol>
<li><p>数组中一定有元素重复，但重复元素个数不知，重复次数不知。由于输出任意一个重复数字即可，故可排序后比较相邻元素。</p>
</li>
<li><p><strong>遗漏信息</strong> ： 数组长度为 n ,数组中的元素均不大于 n。故可以使用哈希表判断。</p>
</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><ol>
<li>排序后比较相邻元素</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findRepeatNumber</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        nums.sort() <span class="comment"># 排序</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums) - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] != nums[i+<span class="number">1</span>]: <span class="comment"># 如果与之后元素不同</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> nums[i]</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(nlogn)，主要开销于数组排序时间<br>空间复杂度：O(1)</p>
<ol start="2">
<li>哈希表(使用set表示)</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findRepeatNumber</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        dic = set()</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums: <span class="comment"># 遍历每个元素</span></span><br><span class="line">            <span class="keyword">if</span> num <span class="keyword">in</span> dic: <span class="comment"># 如果当前元素在哈希表中出现过则有重复</span></span><br><span class="line">                <span class="keyword">return</span> num</span><br><span class="line">            dic.add(num)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)，遍历数组<br>空间复杂度：O(n)，哈希表空间</p>
<h2 id="题解优化"><a href="#题解优化" class="headerlink" title="题解优化"></a>题解优化</h2><p>原地置换</p>
<p>如果没有重复数字，那么正常排序后，数字 i 应该在下标为 i 的位置，所以思路是重头扫描数组，遇到下标为 i 的数字如果不是 i 的话，(假设为 m ),那么我们就拿与下标 m 的数字交换。在交换过程中，如果有重复的数字发生，那么终止返回 ture</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findRepeatNumber</span><span class="params">(self, nums: [int])</span> -&gt; int:</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(nums):</span><br><span class="line">            <span class="keyword">if</span> nums[i] == i:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> nums[nums[i]] == nums[i]: <span class="keyword">return</span> nums[i]</span><br><span class="line">            nums[nums[i]], nums[i] = nums[i], nums[nums[i]]</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode算法(二)</title>
    <url>/2020/09/20/leetcode%E7%AE%97%E6%B3%95-%E4%BA%8C/</url>
    <content><![CDATA[<h1 id="剑指offer04：二维数组中的查找"><a href="#剑指offer04：二维数组中的查找" class="headerlink" title="剑指offer04：二维数组中的查找"></a><a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/" target="_blank" rel="noopener">剑指offer04：二维数组中的查找</a></h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在一个 n * m 的二维数组中，每一行都按照<strong>从左到右递增</strong>的顺序排序，每一列都按照<strong>从上到下递增</strong>的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<p>限制：<br>0 &lt;= n &lt;= 1000<br>0 &lt;= m &lt;= 1000</p>
<a id="more"></a>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ol>
<li><p>由于 n , m 取值范围在 1000 以内，所以可以考虑枚举法，依次循环查找。</p>
</li>
<li><p>从右上角看( matrix[0][m - 1] )来看，是二叉搜索树(左子树均比父节点小，右子树均比父节点大)。所以遇到比当前位置大的数即向下搜索( j + 1 )，如遇比当前位置小的数即向左搜索( i - 1 )</p>
</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findNumberIn2DArray</span><span class="params">(self, matrix: List[List[int]], target: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> matrix <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> len(matrix) == <span class="number">0</span> <span class="keyword">or</span> len(matrix[<span class="number">0</span>]) == <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 注意 None, [], [[]] 三种特殊情况</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        n = len(matrix)</span><br><span class="line">        m = len(matrix[<span class="number">0</span>])</span><br><span class="line">        i, j = <span class="number">0</span>, m<span class="number">-1</span></span><br><span class="line">        <span class="keyword">if</span> target &lt; matrix[<span class="number">0</span>][<span class="number">0</span>] <span class="keyword">or</span> target &gt; matrix[n<span class="number">-1</span>][m<span class="number">-1</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; n <span class="keyword">and</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> matrix[i][j] == target:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> matrix[i][j] &gt; target:</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode算法(三)</title>
    <url>/2020/10/12/leetcode%E7%AE%97%E6%B3%95-%E4%B8%89/</url>
    <content><![CDATA[<h1 id="LeetCode141：环形链表"><a href="#LeetCode141：环形链表" class="headerlink" title="LeetCode141：环形链表"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">LeetCode141：环形链表</a></h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>给定一个链表，判断链表中是否有环。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p>
<p>如果链表中存在环，则返回 true 。 否则，返回 false 。</p>
<p>提示：</p>
<ul>
<li>链表中节点的数目范围是 $[0, 10^4]$</li>
<li>$-10^5$ &lt;= Node.val &lt;= $10^5$</li>
<li>pos 为 -1 或者链表中的一个 有效索引 。<a id="more"></a>
</li>
</ul>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>本问题是判断链表是否有环，这对应两种情况，即有环与无环，故存在三种结题思路：</p>
<ol>
<li><strong>暴力枚举法</strong> : 由于结点数目有限，所以可以使用枚举法，依次遍历，直到遇到 null 返回 false ，或循环 $10^4$ 次后输出 true。</li>
<li><strong>哈希表</strong> : 该方法是暴力法的优化，使用哈希表记录每个遍历的结点，当遇到重复结点时返回 true ，遍历到 null 时返回 false。</li>
<li><strong>快慢指针</strong> : 使用两个指针，分为快指针和慢指针，其中快指针每次前进两格，即  <code>fast = fast.next.next</code> ，慢指针每次前进一格 <code>slow = slow.next</code> ，若链表有环则快慢指针必然会相遇。否则，快指针会先达到 null 。</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>哈希表<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span><span class="params">(self, head: ListNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        dic = set()</span><br><span class="line">        node = head</span><br><span class="line">        <span class="keyword">while</span> node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">in</span> dic:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            dic.add(node)</span><br><span class="line">            node = node.next</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure></p>
<p>快慢指针<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span><span class="params">(self, head: ListNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> head.next <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        fast = head.next</span><br><span class="line">        slow = head</span><br><span class="line">        <span class="keyword">while</span> fast != slow:</span><br><span class="line">            <span class="keyword">if</span> fast.next <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> fast.next.next <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            fast = fast.next.next</span><br><span class="line">            slow = slow.next</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode算法(四)</title>
    <url>/2020/10/12/leetcode%E7%AE%97%E6%B3%95-%E5%9B%9B/</url>
    <content><![CDATA[<h1 id="LeetCode142：环形链表Ⅱ"><a href="#LeetCode142：环形链表Ⅱ" class="headerlink" title="LeetCode142：环形链表Ⅱ"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">LeetCode142：环形链表Ⅱ</a></h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>&emsp;&emsp;给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>
<p>&emsp;&emsp;为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。</p>
<p>提示：</p>
<ul>
<li>链表中节点的数目范围是 $[0, 10^4]$</li>
<li>$-10^5$ &lt;= Node.val &lt;= $10^5$</li>
<li>pos 为 -1 或者链表中的一个 有效索引 。<a id="more"></a>
</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>&emsp;&emsp;与上题<a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">141环形链表类似</a>，但是又有所不同，上题中只需判断是否有环即可，而在本题中需要输出第一个环所在的位置。</p>
<ol>
<li><strong>哈希表</strong> : 使用哈希表记录遍历的每一个结点，当遇到<strong>第一个重复</strong>的结点时，就是环开始的结点位置，将其输出即可。</li>
<li><strong>快慢指针</strong> : 使用两个指针，快指针每次前进两格 <code>fast = fast.next.next</code> , 慢指针每次前进一格 <code>slow = slow.next</code> , 当两指针相遇时，再定义一个指针 ptr 开始从表头开始遍历，当 ptr 与慢指针 slow 相遇时，即是目标结点。</li>
</ol>
<p><img src="/2020/10/12/leetcode%E7%AE%97%E6%B3%95-%E5%9B%9B/142_fig1.png" alt></p>
<p>&emsp;&emsp;如上图所示，其中 a 为链表中非环长度， b 为快慢指针相遇时已走过的环形长度，c 为未走过的距离。所以快指针走过距离为：</p>
<script type="math/tex; mode=display">l_f = a + b + n * (b + c)</script><p>其中，n 为正整数，即相遇时走过的圈数。<br>慢指针走过距离：</p>
<script type="math/tex; mode=display">l_s = a + b</script><p>又由于快指针走过距离为慢指针的两倍，所以有</p>
<script type="math/tex; mode=display">l_f = 2 * l_s --> a = c + (n - 1) * (b + c)</script><p>所以，当快慢指针相遇时，只需再建一个指针指向 head ，与慢指针 slow 同时向前遍历，当相遇时，慢指针 slow 刚好走过 n 圈（快慢指针相遇时，慢指针只走过距离 b ），故二者将在环结点处相遇。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>哈希表<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detectCycle</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        dic = set()</span><br><span class="line">        node = head</span><br><span class="line">        <span class="keyword">while</span> node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">in</span> dic:</span><br><span class="line">                <span class="keyword">return</span> node</span><br><span class="line">            dic.add(node)</span><br><span class="line">            node = node.next</span><br><span class="line">        <span class="keyword">return</span></span><br></pre></td></tr></table></figure></p>
<p>快慢指针<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detectCycle</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> head.next <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        ptr, fast, slow = head, head.next.next, head.next</span><br><span class="line">        <span class="keyword">while</span> fast != slow:</span><br><span class="line">            <span class="keyword">if</span> fast <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> fast.next <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            fast = fast.next.next</span><br><span class="line">            slow = slow.next</span><br><span class="line">        <span class="keyword">while</span> ptr != slow:</span><br><span class="line">            slow = slow.next</span><br><span class="line">            ptr = ptr.next</span><br><span class="line">        <span class="keyword">return</span> ptr</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode算法(五)</title>
    <url>/2020/10/14/leetcode%E7%AE%97%E6%B3%95-%E4%BA%94/</url>
    <content><![CDATA[<h1 id="剑指offer022：链表中倒数第k个节点"><a href="#剑指offer022：链表中倒数第k个节点" class="headerlink" title="剑指offer022：链表中倒数第k个节点"></a><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/" target="_blank" rel="noopener">剑指offer022：链表中倒数第k个节点</a></h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。</p>
<a id="more"></a>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ol>
<li>先遍历一遍获取链表长度，再寻找倒数第 k 个节点</li>
<li>使用双指针，二者之间相差 k 个节点，当前指针指向空时，后面指针即是最终返回结果。</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getKthFromEnd</span><span class="params">(self, head: ListNode, k: int)</span> -&gt; ListNode:</span></span><br><span class="line">        right, left = head, head</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">            right = right.next</span><br><span class="line">        <span class="keyword">while</span> right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            right = right.next</span><br><span class="line">            left = left.next</span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>噪声环境下的目标检测跟踪问题</title>
    <url>/2020/10/16/%E5%99%AA%E5%A3%B0%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E8%B7%9F%E8%B8%AA%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="噪声环境下的目标检测跟踪问题"><a href="#噪声环境下的目标检测跟踪问题" class="headerlink" title="噪声环境下的目标检测跟踪问题"></a>噪声环境下的目标检测跟踪问题</h1><h2 id="一、数据显示"><a href="#一、数据显示" class="headerlink" title="一、数据显示"></a>一、数据显示</h2><p>&emsp;&emsp;使用 load() 函数读取数据集<br>数据集格式：$ 250 <em> 250 </em> 50 $ 表示为 $ 250 km^2 $ 的区域，每 $ 1 km^2 $ 记录一次数据，且记录 50 帧数据。</p>
<a id="more"></a>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear; clc;</span><br><span class="line">x = <span class="number">1</span>:<span class="number">1</span>:<span class="number">250</span>;</span><br><span class="line">y = <span class="number">1</span>:<span class="number">1</span>:<span class="number">250</span>;</span><br><span class="line">load(<span class="string">'Raw_data.mat'</span>);</span><br><span class="line">[xx,yy] = <span class="built_in">meshgrid</span>(x,y);</span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line"><span class="comment">% for i = 1 : 50</span></span><br><span class="line"><span class="comment">%     surf(xx, yy, raw_data(:,:,i));</span></span><br><span class="line"><span class="comment">% end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% i = input('输入显示帧数（1~50）');</span></span><br><span class="line">surf(xx, yy, raw_data(:,:,<span class="number">30</span>));</span><br><span class="line">xlabel(<span class="string">'x/m'</span>); ylabel(<span class="string">'y/m'</span>); zlabel(<span class="string">'Amplitude/dB'</span>);</span><br></pre></td></tr></table></figure>
<p><img src="/2020/10/16/%E5%99%AA%E5%A3%B0%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E8%B7%9F%E8%B8%AA%E9%97%AE%E9%A2%98/showData.jpg" alt></p>
<h2 id="二、恒虚警检测"><a href="#二、恒虚警检测" class="headerlink" title="二、恒虚警检测"></a>二、恒虚警检测</h2><h3 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h3><p>&emsp;&emsp;雷达系统在保持<strong>虚警概率</strong>恒定的条件下对接收机输出信号与噪声作判别以确定目标信号是否存在的技术。</p>
<h3 id="2-2-原理"><a href="#2-2-原理" class="headerlink" title="2.2 原理"></a>2.2 原理</h3><p>&emsp;&emsp;对输入的噪声进行处理后确定一个门限，将此门限与输入信号相对比，如果输入信号超过了此门限，则判为有目标；否则，判为无目标。</p>
<p><img src="/2020/10/16/%E5%99%AA%E5%A3%B0%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E8%B7%9F%E8%B8%AA%E9%97%AE%E9%A2%98/figure1.jpg" alt></p>
<p>&emsp;&emsp;如上图所示，门限电压设为 1V , 当输入信号大于 1V 时判为有目标；反之没有。</p>
<p>&emsp;&emsp;注意在上图中为没有噪声干扰的情况下所得结果，然而在一般情况下，信号在传播过程中都会遇到噪声，故到达接收机后需要进行处理，并根据适当的准则对输入信号做出判决。</p>
<h3 id="2-3-数学表示"><a href="#2-3-数学表示" class="headerlink" title="2.3 数学表示"></a>2.3 数学表示</h3><p>&emsp;&emsp;假设发送端信号为 $ s(t) $, 接收端为 $ x(t) = s(t) + n(t) $<br>用 $ H_0 $ 和 $ H_1 $ 分别表示接收机的无、有信号输入的假设。<br>用 $ D_0 $ 和 $ D_1 $ 分别表示检测器作出无、有信号的判决结果。</p>
<p>则四种关系分别如下表所示</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center">$ H_0 $</th>
<th>$ H_1 $</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">$ D_0 $</td>
<td style="text-align:center">正确不被发现</td>
<td>漏警</td>
<td></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">$ D_1 $</td>
<td style="text-align:center">虚警</td>
<td>正确检测</td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;&emsp;用 $ p(z|H_0) $ 和 $ p(z|H_1) $ 分别表示无、有信号输入时，输出端的信号电平的概率密度函数。同时，用 $ Z_0 $ 和 $ Z_1 $ 来分别表示检测器做出无、有信号判决的判决区域。</p>
<p><img src="/2020/10/16/%E5%99%AA%E5%A3%B0%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E8%B7%9F%E8%B8%AA%E9%97%AE%E9%A2%98/figure2.jpg" alt></p>
<p>&emsp;&emsp;如上图所示，门限电压(即虚线部分)将两个函数所包涵区域分为四个部分，其中</p>
<ul>
<li>$ \int_{Z_0}p(z|H_0)dz $ : 正确不被发现</li>
<li>$ \int_{Z_0}p(z|H_1)dz $ : 漏警</li>
<li>$ \int_{Z_1}p(z|H_0)dz $ : 虚警</li>
<li>$ \int_{Z_1}p(z|H_1)dz $ : 正确检测</li>
</ul>
<h3 id="2-4-推导"><a href="#2-4-推导" class="headerlink" title="2.4 推导"></a>2.4 推导</h3><p>&emsp;&emsp;设虚警概率为 $ P_F $, 漏警概率为 $ P_M $, 检测概率为 $ P_D $, 则 N-P 准则为</p>
<p>$   \begin{cases}<br>    P_F = \alpha (\alpha 一般取 0.1 ~ 0.05) \\<br>    P_M = min 或 P_D = 1 - P_M = max<br>    \end{cases}  $</p>
<p>利用拉格朗日乘子 $ \lambda $ 构造目标函数</p>
<script type="math/tex; mode=display">J = P_M + \lambda(P_F - \alpha)</script><script type="math/tex; mode=display">= \int_{Z_0}p(z|H_1)dz + \lambda[\int_{Z_1}p(z|H_0)dz - \alpha]dz</script><script type="math/tex; mode=display">= \int_{Z_0}p(z|H_1)dz + \lambda[1 - \int_{Z_0}p(z|H_0)dz - \alpha]dz</script><script type="math/tex; mode=display">= \lambda(1-\alpha) + \int_{Z_0} [p(z|H_1) - \lambda p(z|H_1)]dz</script><p>&emsp;&emsp;当$ P_F = \alpha $ 时，令 J 最小即令 $ P_M $ 最小，则令 J 对 $ z_0 $ 的导数为 0 ，也就是积分号内值为 0 ，则</p>
<script type="math/tex; mode=display">\int_{Z_0} [p(z|H_1) - \lambda p(z|H_1)]dz</script><script type="math/tex; mode=display">= \int_{-\infty}^{z_0} [p(z|H_1) - \lambda p(z|H_1)]dz</script><p>根据变上限求导公式，有</p>
<script type="math/tex; mode=display">p(z_0|H_1) - \lambda p(z_0|H_0) = 0</script><script type="math/tex; mode=display">\lambda = \frac{p(z_0|H_1)}{p(z_0|H_0)} = \lambda (z_0)</script><p>其中，$ z_0 $为电平比较门限，似然比为 $ \lambda (z) = \frac{p(z|H_1)}{p(z|H_0)} $<br>&emsp;&emsp;若输入电平 z 大于 $ z_0 $, 即 $ \lambda (z) $ 大于 $ \lambda $, 判决有信号输入；若输入电平 z 小于 $ z_0 $, 即 $ \lambda (z) $ 小于 $ \lambda $, 判决有信号输入。</p>
]]></content>
      <categories>
        <category>科研</category>
        <category>大四学习</category>
      </categories>
      <tags>
        <tag>matlab</tag>
        <tag>目标检测跟踪</tag>
        <tag>恒虚检测</tag>
        <tag>卡尔曼滤波</tag>
      </tags>
  </entry>
</search>
