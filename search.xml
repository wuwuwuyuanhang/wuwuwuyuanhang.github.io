<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>leetcode算法(一)</title>
    <url>/2020/09/18/leetcode%E7%AE%97%E6%B3%95-%E4%B8%80/</url>
    <content><![CDATA[<h1 id="剑指offer03：数组中重复的数字"><a href="#剑指offer03：数组中重复的数字" class="headerlink" title="剑指offer03：数组中重复的数字"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/" target="_blank" rel="noopener">剑指offer03：数组中重复的数字</a></h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在一个长度为 n 的数组 nums 里的所有数字都在 <strong>0～n-1</strong> 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p>
<p>限制 : 2 &lt;= n &lt;= 100000</p>
<a id="more"></a>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ol>
<li><p>数组中一定有元素重复，但重复元素个数不知，重复次数不知。由于输出任意一个重复数字即可，故可排序后比较相邻元素。</p>
</li>
<li><p><strong>遗漏信息</strong> ： 数组长度为 n ,数组中的元素均不大于 n。故可以使用哈希表判断。</p>
</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><ol>
<li>排序后比较相邻元素</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findRepeatNumber</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        nums.sort() <span class="comment"># 排序</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums) - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] != nums[i+<span class="number">1</span>]: <span class="comment"># 如果与之后元素不同</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> nums[i]</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(nlogn)，主要开销于数组排序时间<br>空间复杂度：O(1)</p>
<ol start="2">
<li>哈希表(使用set表示)</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findRepeatNumber</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        dic = set()</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums: <span class="comment"># 遍历每个元素</span></span><br><span class="line">            <span class="keyword">if</span> num <span class="keyword">in</span> dic: <span class="comment"># 如果当前元素在哈希表中出现过则有重复</span></span><br><span class="line">                <span class="keyword">return</span> num</span><br><span class="line">            dic.add(num)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)，遍历数组<br>空间复杂度：O(n)，哈希表空间</p>
<h2 id="题解优化"><a href="#题解优化" class="headerlink" title="题解优化"></a>题解优化</h2><p>原地置换</p>
<p>如果没有重复数字，那么正常排序后，数字 i 应该在下标为 i 的位置，所以思路是重头扫描数组，遇到下标为 i 的数字如果不是 i 的话，(假设为 m ),那么我们就拿与下标 m 的数字交换。在交换过程中，如果有重复的数字发生，那么终止返回 ture</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findRepeatNumber</span><span class="params">(self, nums: [int])</span> -&gt; int:</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(nums):</span><br><span class="line">            <span class="keyword">if</span> nums[i] == i:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> nums[nums[i]] == nums[i]: <span class="keyword">return</span> nums[i]</span><br><span class="line">            nums[nums[i]], nums[i] = nums[i], nums[nums[i]]</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode算法(二)</title>
    <url>/2020/09/20/leetcode%E7%AE%97%E6%B3%95-%E4%BA%8C/</url>
    <content><![CDATA[<h1 id="剑指offer04：二维数组中的查找"><a href="#剑指offer04：二维数组中的查找" class="headerlink" title="剑指offer04：二维数组中的查找"></a><a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/" target="_blank" rel="noopener">剑指offer04：二维数组中的查找</a></h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在一个 n * m 的二维数组中，每一行都按照<strong>从左到右递增</strong>的顺序排序，每一列都按照<strong>从上到下递增</strong>的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<p>限制：<br>0 &lt;= n &lt;= 1000<br>0 &lt;= m &lt;= 1000</p>
<a id="more"></a>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ol>
<li><p>由于 n , m 取值范围在 1000 以内，所以可以考虑枚举法，依次循环查找。</p>
</li>
<li><p>从右上角看( matrix[0][m - 1] )来看，是二叉搜索树(左子树均比父节点小，右子树均比父节点大)。所以遇到比当前位置大的数即向下搜索( j + 1 )，如遇比当前位置小的数即向左搜索( i - 1 )</p>
</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findNumberIn2DArray</span><span class="params">(self, matrix: List[List[int]], target: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> matrix <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> len(matrix) == <span class="number">0</span> <span class="keyword">or</span> len(matrix[<span class="number">0</span>]) == <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 注意 None, [], [[]] 三种特殊情况</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        n = len(matrix)</span><br><span class="line">        m = len(matrix[<span class="number">0</span>])</span><br><span class="line">        i, j = <span class="number">0</span>, m<span class="number">-1</span></span><br><span class="line">        <span class="keyword">if</span> target &lt; matrix[<span class="number">0</span>][<span class="number">0</span>] <span class="keyword">or</span> target &gt; matrix[n<span class="number">-1</span>][m<span class="number">-1</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; n <span class="keyword">and</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> matrix[i][j] == target:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> matrix[i][j] &gt; target:</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode算法(三)</title>
    <url>/2020/10/12/leetcode%E7%AE%97%E6%B3%95-%E4%B8%89/</url>
    <content><![CDATA[<h1 id="LeetCode141：环形链表"><a href="#LeetCode141：环形链表" class="headerlink" title="LeetCode141：环形链表"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">LeetCode141：环形链表</a></h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>给定一个链表，判断链表中是否有环。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p>
<p>如果链表中存在环，则返回 true 。 否则，返回 false 。</p>
<p>提示：</p>
<ul>
<li>链表中节点的数目范围是 $[0, 10^4]$</li>
<li>$-10^5$ &lt;= Node.val &lt;= $10^5$</li>
<li>pos 为 -1 或者链表中的一个 有效索引 。<a id="more"></a>
</li>
</ul>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>本问题是判断链表是否有环，这对应两种情况，即有环与无环，故存在三种结题思路：</p>
<ol>
<li><strong>暴力枚举法</strong> : 由于结点数目有限，所以可以使用枚举法，依次遍历，直到遇到 null 返回 false ，或循环 $10^4$ 次后输出 true。</li>
<li><strong>哈希表</strong> : 该方法是暴力法的优化，使用哈希表记录每个遍历的结点，当遇到重复结点时返回 true ，遍历到 null 时返回 false。</li>
<li><strong>快慢指针</strong> : 使用两个指针，分为快指针和慢指针，其中快指针每次前进两格，即  <code>fast = fast.next.next</code> ，慢指针每次前进一格 <code>slow = slow.next</code> ，若链表有环则快慢指针必然会相遇。否则，快指针会先达到 null 。</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>哈希表<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span><span class="params">(self, head: ListNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        dic = set()</span><br><span class="line">        node = head</span><br><span class="line">        <span class="keyword">while</span> node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">in</span> dic:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            dic.add(node)</span><br><span class="line">            node = node.next</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure></p>
<p>快慢指针<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span><span class="params">(self, head: ListNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> head.next <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        fast = head.next</span><br><span class="line">        slow = head</span><br><span class="line">        <span class="keyword">while</span> fast != slow:</span><br><span class="line">            <span class="keyword">if</span> fast.next <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> fast.next.next <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            fast = fast.next.next</span><br><span class="line">            slow = slow.next</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode算法(四)</title>
    <url>/2020/10/12/leetcode%E7%AE%97%E6%B3%95-%E5%9B%9B/</url>
    <content><![CDATA[<h1 id="LeetCode142：环形链表Ⅱ"><a href="#LeetCode142：环形链表Ⅱ" class="headerlink" title="LeetCode142：环形链表Ⅱ"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">LeetCode142：环形链表Ⅱ</a></h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>&emsp;&emsp;给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>
<p>&emsp;&emsp;为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。</p>
<p>提示：</p>
<ul>
<li>链表中节点的数目范围是 $[0, 10^4]$</li>
<li>$-10^5$ &lt;= Node.val &lt;= $10^5$</li>
<li>pos 为 -1 或者链表中的一个 有效索引 。<a id="more"></a>
</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>&emsp;&emsp;与上题<a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">141环形链表类似</a>，但是又有所不同，上题中只需判断是否有环即可，而在本题中需要输出第一个环所在的位置。</p>
<ol>
<li><strong>哈希表</strong> : 使用哈希表记录遍历的每一个结点，当遇到<strong>第一个重复</strong>的结点时，就是环开始的结点位置，将其输出即可。</li>
<li><strong>快慢指针</strong> : 使用两个指针，快指针每次前进两格 <code>fast = fast.next.next</code> , 慢指针每次前进一格 <code>slow = slow.next</code> , 当两指针相遇时，再定义一个指针 ptr 开始从表头开始遍历，当 ptr 与慢指针 slow 相遇时，即是目标结点。</li>
</ol>
<p><img src="/2020/10/12/leetcode%E7%AE%97%E6%B3%95-%E5%9B%9B/142_fig1.png" alt></p>
<p>&emsp;&emsp;如上图所示，其中 a 为链表中非环长度， b 为快慢指针相遇时已走过的环形长度，c 为未走过的距离。所以快指针走过距离为：</p>
<script type="math/tex; mode=display">l_f = a + b + n * (b + c)</script><p>其中，n 为正整数，即相遇时走过的圈数。<br>慢指针走过距离：</p>
<script type="math/tex; mode=display">l_s = a + b</script><p>又由于快指针走过距离为慢指针的两倍，所以有</p>
<script type="math/tex; mode=display">l_f = 2 * l_s --> a = c + (n - 1) * (b + c)</script><p>所以，当快慢指针相遇时，只需再建一个指针指向 head ，与慢指针 slow 同时向前遍历，当相遇时，慢指针 slow 刚好走过 n 圈（快慢指针相遇时，慢指针只走过距离 b ），故二者将在环结点处相遇。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>哈希表<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detectCycle</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        dic = set()</span><br><span class="line">        node = head</span><br><span class="line">        <span class="keyword">while</span> node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">in</span> dic:</span><br><span class="line">                <span class="keyword">return</span> node</span><br><span class="line">            dic.add(node)</span><br><span class="line">            node = node.next</span><br><span class="line">        <span class="keyword">return</span></span><br></pre></td></tr></table></figure></p>
<p>快慢指针<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detectCycle</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> head.next <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        ptr, fast, slow = head, head.next.next, head.next</span><br><span class="line">        <span class="keyword">while</span> fast != slow:</span><br><span class="line">            <span class="keyword">if</span> fast <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> fast.next <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            fast = fast.next.next</span><br><span class="line">            slow = slow.next</span><br><span class="line">        <span class="keyword">while</span> ptr != slow:</span><br><span class="line">            slow = slow.next</span><br><span class="line">            ptr = ptr.next</span><br><span class="line">        <span class="keyword">return</span> ptr</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode算法(五)</title>
    <url>/2020/10/14/leetcode%E7%AE%97%E6%B3%95-%E4%BA%94/</url>
    <content><![CDATA[<h1 id="剑指offer022：链表中倒数第k个节点"><a href="#剑指offer022：链表中倒数第k个节点" class="headerlink" title="剑指offer022：链表中倒数第k个节点"></a><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/" target="_blank" rel="noopener">剑指offer022：链表中倒数第k个节点</a></h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。</p>
<a id="more"></a>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ol>
<li>先遍历一遍获取链表长度，再寻找倒数第 k 个节点</li>
<li>使用双指针，二者之间相差 k 个节点，当前指针指向空时，后面指针即是最终返回结果。</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getKthFromEnd</span><span class="params">(self, head: ListNode, k: int)</span> -&gt; ListNode:</span></span><br><span class="line">        right, left = head, head</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">            right = right.next</span><br><span class="line">        <span class="keyword">while</span> right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            right = right.next</span><br><span class="line">            left = left.next</span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>噪声环境下的目标检测跟踪问题</title>
    <url>/2020/10/16/%E5%99%AA%E5%A3%B0%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E8%B7%9F%E8%B8%AA%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="噪声环境下的目标检测跟踪问题"><a href="#噪声环境下的目标检测跟踪问题" class="headerlink" title="噪声环境下的目标检测跟踪问题"></a>噪声环境下的目标检测跟踪问题</h1><h2 id="一、数据显示"><a href="#一、数据显示" class="headerlink" title="一、数据显示"></a>一、数据显示</h2><p>&emsp;&emsp;使用 load() 函数读取数据集<br>数据集格式：250 * 250 * 50 表示为 $ 250 {km}^2 $ 的区域，每 $ 1 {km}^2 $ 记录一次数据，且记录 50 帧数据。</p>
<a id="more"></a>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[]</span> = <span class="title">showData</span><span class="params">( raw_data )</span></span></span><br><span class="line"><span class="comment">%% 可视化加载数据</span></span><br><span class="line"><span class="comment">% </span></span><br><span class="line"><span class="comment">% 输入参数</span></span><br><span class="line"><span class="comment">% raw_data : 单帧采集的数据</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line">mesh(raw_data)</span><br><span class="line">xlabel(<span class="string">'x/m'</span>,<span class="string">'fontsize'</span>,<span class="number">14</span>); ylabel(<span class="string">'y/m'</span>,<span class="string">'fontsize'</span>,<span class="number">14</span>); zlabel(<span class="string">'Amplitude/dB'</span>,<span class="string">'fontsize'</span>,<span class="number">14</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><img src="/2020/10/16/%E5%99%AA%E5%A3%B0%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E8%B7%9F%E8%B8%AA%E9%97%AE%E9%A2%98/showData.jpg" alt></p>
<h2 id="二、恒虚警检测"><a href="#二、恒虚警检测" class="headerlink" title="二、恒虚警检测"></a>二、恒虚警检测</h2><h3 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h3><p>&emsp;&emsp;雷达系统在保持<strong>虚警概率</strong>恒定的条件下对接收机输出信号与噪声作判别以确定目标信号是否存在的技术。</p>
<h3 id="2-2-原理"><a href="#2-2-原理" class="headerlink" title="2.2 原理"></a>2.2 原理</h3><p>&emsp;&emsp;对输入的噪声进行处理后确定一个门限，将此门限与输入信号相对比，如果输入信号超过了此门限，则判为有目标；否则，判为无目标。</p>
<p><img src="/2020/10/16/%E5%99%AA%E5%A3%B0%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E8%B7%9F%E8%B8%AA%E9%97%AE%E9%A2%98/figure1.jpg" alt></p>
<p>&emsp;&emsp;如上图所示，门限电压设为 1V , 当输入信号大于 1V 时判为有目标；反之没有。</p>
<p>&emsp;&emsp;注意在上图中为没有噪声干扰的情况下所得结果，然而在一般情况下，信号在传播过程中都会遇到噪声，故到达接收机后需要进行处理，并根据适当的准则对输入信号做出判决。</p>
<h3 id="2-3-数学表示"><a href="#2-3-数学表示" class="headerlink" title="2.3 数学表示"></a>2.3 数学表示</h3><p>&emsp;&emsp;假设发送端信号为 $ s(t) $, 接收端为 $ x(t) = s(t) + n(t) $<br>用 $ H_0 $ 和 $ H_1 $ 分别表示接收机的无、有信号输入的假设。<br>用 $ D_0 $ 和 $ D_1 $ 分别表示检测器作出无、有信号的判决结果。</p>
<p>则四种关系分别如下表所示</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center">$ H_0 $</th>
<th>$ H_1 $</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">$ D_0 $</td>
<td style="text-align:center">正确不被发现</td>
<td>漏警</td>
<td></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">$ D_1 $</td>
<td style="text-align:center">虚警</td>
<td>正确检测</td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;&emsp;用 $ p(z|H_0) $ 和 $ p(z|H_1) $ 分别表示无、有信号输入时，输出端的信号电平的概率密度函数。同时，用 $ Z_0 $ 和 $ Z_1 $ 来分别表示检测器做出无、有信号判决的判决区域。</p>
<p><img src="/2020/10/16/%E5%99%AA%E5%A3%B0%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E8%B7%9F%E8%B8%AA%E9%97%AE%E9%A2%98/figure2.jpg" alt></p>
<p>&emsp;&emsp;如上图所示，门限电压(即虚线部分)将两个函数所包涵区域分为四个部分，其中</p>
<ul>
<li>$ \int_{Z_0}p(z|H_0)dz $ : 正确不被发现</li>
<li>$ \int_{Z_0}p(z|H_1)dz $ : 漏警</li>
<li>$ \int_{Z_1}p(z|H_0)dz $ : 虚警</li>
<li>$ \int_{Z_1}p(z|H_1)dz $ : 正确检测</li>
</ul>
<h3 id="2-4-推导"><a href="#2-4-推导" class="headerlink" title="2.4 推导"></a>2.4 推导</h3><p>&emsp;&emsp;设虚警概率为 $ P_F $, 漏警概率为 $ P_M $, 检测概率为 $ P_D $, 则 N-P 准则为</p>
<p>$   \begin{cases}<br>    P_F = \alpha (\alpha 一般取 0.1 ~ 0.05) \\<br>    P_M = min 或 P_D = 1 - P_M = max<br>    \end{cases}  $</p>
<p>利用拉格朗日乘子 $ \lambda $ 构造目标函数</p>
<script type="math/tex; mode=display">J = P_M + \lambda(P_F - \alpha)</script><script type="math/tex; mode=display">= \int_{Z_0}p(z|H_1)dz + \lambda[\int_{Z_1}p(z|H_0)dz - \alpha]</script><script type="math/tex; mode=display">= \int_{Z_0}p(z|H_1)dz + \lambda[1 - \int_{Z_0}p(z|H_0)dz - \alpha]</script><script type="math/tex; mode=display">= \lambda(1-\alpha) + \int_{Z_0} [p(z|H_1) - \lambda p(z|H_1)]dz</script><p>&emsp;&emsp;当$ P_F = \alpha $ 时，令 J 最小即令 $ P_M $ 最小，则令 J 对 $ z_0 $ 的导数为 0 ，也就是积分号内值为 0 ，则</p>
<script type="math/tex; mode=display">\int_{Z_0} [p(z|H_1) - \lambda p(z|H_1)]dz</script><script type="math/tex; mode=display">= \int_{-\infty}^{z_0} [p(z|H_1) - \lambda p(z|H_1)]dz</script><p>根据变上限求导公式，有</p>
<script type="math/tex; mode=display">p(z_0|H_1) - \lambda p(z_0|H_0) = 0</script><script type="math/tex; mode=display">\lambda = \frac{p(z_0|H_1)}{p(z_0|H_0)} = \lambda (z_0)</script><p>其中，$ z_0 $为电平比较门限，似然比为 $ \lambda (z) = \frac{p(z|H_1)}{p(z|H_0)} $<br>&emsp;&emsp;若输入电平 z 大于 $ z_0 $, 即 $ \lambda (z) $ 大于 $ \lambda $, 判决有信号输入；若输入电平 z 小于 $ z_0 $, 即 $ \lambda (z) $ 小于 $ \lambda $, 判决有信号输入。<br>其中 $ \lambda $ 的取值由 $ P_F = \alpha $ 确定，在输入信号是一维的情况下，</p>
<ol>
<li><script type="math/tex; mode=display">\int_{\lambda}^{\infty} p[\lambda (z)|H_0]d \lambda (z) = \alpha</script></li>
<li>先求 $ z_0 $<script type="math/tex; mode=display">P_F = \int_{z_0}^{\infty}p(z|H_0)dz</script>再求 $ \lambda $<script type="math/tex; mode=display">\lambda = \frac{p(z_0|H_1)}{p(z_0|H_0)}</script></li>
</ol>
<h3 id="2-5-单元平均恒虚警技术"><a href="#2-5-单元平均恒虚警技术" class="headerlink" title="2.5 单元平均恒虚警技术"></a>2.5 单元平均恒虚警技术</h3><p><img src="/2020/10/16/%E5%99%AA%E5%A3%B0%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E8%B7%9F%E8%B8%AA%E9%97%AE%E9%A2%98/ca-cfar.png" alt><br><img src="/2020/10/16/%E5%99%AA%E5%A3%B0%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E8%B7%9F%E8%B8%AA%E9%97%AE%E9%A2%98/figure3.png" alt></p>
<p>&emsp;&emsp;需要检测”检测单元”(Cell Under Test)是否大于阈值(T)，在检测单元两侧需要各留出一些”保护单元”(Guard Cells)，，保护单元的总数略大目标所在占的分辨单元数，保护单元主要是用于避免检测单元本身的功率而破坏检测，在估计检测的时候保护单元不参与计算。</p>
<script type="math/tex; mode=display">T=\alpha P_n</script><script type="math/tex; mode=display">\alpha = N(P_{fa}^{-1/N} - 1)</script><script type="math/tex; mode=display">P_n = \frac{1}{N}\sum_{j=1}^{N}x_m</script><p>其中，$ \alpha $ 是阈值因子(threshold factor)，$ P_n $ 是参考单元(training cells)的噪声功率，$ N $ 是参考单元的个数，$ P_fa $ 是虚警概率。</p>
<h3 id="2-6-代码"><a href="#2-6-代码" class="headerlink" title="2.6 代码"></a>2.6 代码</h3><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[ data_k ]</span> = <span class="title">ca_cfar</span><span class="params">( n_row,n_col,raw_data_k )</span></span></span><br><span class="line"><span class="comment">%% 实现ca-cfar的函数</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% 假定：平方律检波器，干扰噪声独立呈指数分布（检测前）</span></span><br><span class="line"><span class="comment">% 待定：检测单元数、参考单元数</span></span><br><span class="line"><span class="comment">% 存疑：参考单元间距（距离分辨率）</span></span><br><span class="line"><span class="comment">% 当处理窗大到刚好容纳其他目标时，检测数目会骤减</span></span><br><span class="line"><span class="comment">% 当保护窗小到没有包含目标跨越单元时，检测数目会骤减</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% 参数设置</span></span><br><span class="line"><span class="comment">% n_row : 输入数据行数</span></span><br><span class="line"><span class="comment">% n_rol : 输入数据列数</span></span><br><span class="line"><span class="comment">% raw_data_k : 第k帧数据</span></span><br><span class="line"><span class="comment">% 返回数据</span></span><br><span class="line"><span class="comment">% data_k : 处理后的数据</span></span><br><span class="line"></span><br><span class="line">data_square=raw_data_k.*<span class="built_in">conj</span>(raw_data_k); <span class="comment">% 功率</span></span><br><span class="line"><span class="comment">% 限定处理窗大小</span></span><br><span class="line">up=<span class="number">4</span>;</span><br><span class="line">down=up;</span><br><span class="line">left=up; </span><br><span class="line">right=up;</span><br><span class="line"><span class="comment">% 限定保护单元</span></span><br><span class="line">left_pro=<span class="number">0</span>; </span><br><span class="line">right_pro=left_pro;</span><br><span class="line">up_pro=left_pro;</span><br><span class="line">down_pro=left_pro;</span><br><span class="line"><span class="comment">% 参考单元数</span></span><br><span class="line">num_refer=(up+down+<span class="number">1</span>)*(left+right+<span class="number">1</span>)-(left_pro+right_pro+<span class="number">1</span>)*(up_pro+down_pro+<span class="number">1</span>); </span><br><span class="line">Pfa=<span class="number">1e-5</span>; <span class="comment">% 恒虚警率</span></span><br><span class="line">alpha=num_refer*(Pfa^(<span class="number">-1</span>/num_refer)<span class="number">-1</span>); <span class="comment">% 门限乘积因子</span></span><br><span class="line">data_k=<span class="built_in">zeros</span>(n_row,n_col); <span class="comment">% 检测后的数据</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=down+<span class="number">1</span>:n_row-up <span class="comment">% 行</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span>=left+<span class="number">1</span>:n_col-right <span class="comment">% 列</span></span><br><span class="line">     data_select=sum(sum(data_square(<span class="built_in">i</span>-down:<span class="built_in">i</span>+up,<span class="built_in">j</span>-left:<span class="built_in">j</span>+right)))...</span><br><span class="line">         -sum(sum(data_square(<span class="built_in">i</span>-down_pro:<span class="built_in">i</span>+up_pro,<span class="built_in">j</span>-left_pro:<span class="built_in">j</span>+right_pro))); <span class="comment">% 参考单元总功率</span></span><br><span class="line">     threshold=data_select/num_refer*alpha; <span class="comment">% 参考单元的平均能量*门限乘积因子</span></span><br><span class="line">     <span class="keyword">if</span> data_square(<span class="built_in">i</span>,<span class="built_in">j</span>)&gt;=threshold</span><br><span class="line">        data_k(<span class="built_in">i</span>,<span class="built_in">j</span>)=<span class="number">1</span>; <span class="comment">% 判定存在目标</span></span><br><span class="line">     <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>参考文献</p>
<blockquote>
<p><a href="https://blog.csdn.net/weixin_42647783/article/details/89449048?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param" target="_blank" rel="noopener">恒虚警检测（Constant False Alarm Rate, CFAR）</a></p>
</blockquote>
</blockquote>
<h2 id="三、卡尔曼滤波"><a href="#三、卡尔曼滤波" class="headerlink" title="三、卡尔曼滤波"></a>三、卡尔曼滤波</h2><p>卡尔曼滤波将单独开一个坑，具体链接之后上传</p>
]]></content>
      <categories>
        <category>科研</category>
        <category>大四学习</category>
      </categories>
      <tags>
        <tag>matlab</tag>
        <tag>目标检测跟踪</tag>
        <tag>恒虚检测</tag>
        <tag>卡尔曼滤波</tag>
      </tags>
  </entry>
  <entry>
    <title>卡尔曼滤波</title>
    <url>/2020/10/22/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/</url>
    <content><![CDATA[<h1 id="卡尔曼滤波"><a href="#卡尔曼滤波" class="headerlink" title="卡尔曼滤波"></a>卡尔曼滤波</h1><p>&emsp;&emsp;传说中将阿波罗号送上月球的算法</p>
<a id="more"></a>
<h2 id="1-1、定义"><a href="#1-1、定义" class="headerlink" title="1.1、定义"></a>1.1、定义</h2><p>首先来看<a href="https://baike.baidu.com/item/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2" target="_blank" rel="noopener">百度百科</a>对其定义</p>
<blockquote>
<p>&emsp;&emsp;卡尔曼滤波是一种利用线性状态的方程，通过系统输入输出观测数据，对系统状态进行最优估计的算法。<br>&emsp;&emsp;其是在线性状态空间表示的基础上对有噪声的输入和观测信号进行处理，求取系统状态或真实信号。</p>
</blockquote>
<p>&emsp;&emsp;而按照个人学习的理解，简单来讲，即在噪声干扰的环境下可以对得到目标的当前状态(位置、速度等)进行下一步的最佳的估计。</p>
<h2 id="1-2、举例分析"><a href="#1-2、举例分析" class="headerlink" title="1.2、举例分析"></a>1.2、举例分析</h2><p>&emsp;&emsp;这里引用最为普遍的例子，运动小车的例子。<br>小车一般而言有两个状态参量，位置 p 与速度 v ，则令小车第 k 时刻的状态为</p>
<script type="math/tex; mode=display">
\hat { x } _ { k } = \left[ \begin{array} { l } p \\ v \end{array} \right]</script><p>&emsp;&emsp;1. 首先分析在无外力的条件下(即无外界噪声影响)，根据牛顿第一定律我们可以得到小车将做匀速直线运动，则对于 k 时刻的状态可由前一时刻，即 k - 1 时的状态预测出来，即</p>
<script type="math/tex; mode=display">
\left\{ \begin{array} { l } p _ { k } = p _ { k - 1 } + \Delta t \cdot v _ { k - 1 } \\ v _ { k } = v _ { k - 1 } \end{array} \right.</script><p>转换为矩阵形式，即</p>
<script type="math/tex; mode=display">
\begin{aligned} \hat { x } _ { k } = \left[ \begin{array} { c } p _ { k } \\ v _ { k } \end{array} \right] & = \left[ \begin{array} { c c } 1 & \Delta t \\ 0 & 1 \end{array} \right] \left[ \begin{array} { c } p _ { k - 1 } \\ v _ { k - 1 } \end{array} \right] \\ & = F _ { k } \hat { x } _ { k - 1 } \end{aligned}</script><p>其中，$ F _ { k } $ 记为预测矩阵。</p>
<p>&emsp;&emsp; 除了均值外，估计的数据还存在一个数学表示——方差——用于表示数据在均值周围的偏差大小。由于存在位置和速度两个变量所以，其协方差矩阵表示为</p>
<script type="math/tex; mode=display">
P _ { k } = \left[ \begin{array} { c c } \sum _ { p p } & \Sigma _ { p v } \\ \sum _ { v p } & \Sigma _ { v v } \end{array} \right]</script><p>根据数学中的先验知识，我们将矩阵中的每个点都乘以于矩阵 A ，则其协方差将变为</p>
<script type="math/tex; mode=display">
\begin{array} { l } \operatorname { Cov } ( x ) = \Sigma \\ \operatorname { Cov } ( A x ) = A \Sigma A ^ { \top } \end{array}</script><p>所以变换后有</p>
<script type="math/tex; mode=display">
\left\{ \begin{array} { l } \hat { x } _ { k } = F _ { k } \hat { x } _ { k - 1 } \\ P _ { k } = F _ { k } P _ { k - 1 } F _ { k } ^ { T } \end{array} \right.</script><p>&emsp;&emsp;2. 若考虑外力的影响(存在外界噪声干扰)，则设小车还存在一个加速度 a ，根据牛顿第二定律我们可以得到</p>
<script type="math/tex; mode=display">
\left\{ \begin{array} { l } p _ { k } = p _ { k - 1 } + \Delta t \cdot v _ { k - 1 } + \frac { \Delta t ^ { 2 } } { 2 } \cdot a \\ v _ { k } = v _ { k - 1 } + \Delta t \cdot a \end{array} \right.</script><script type="math/tex; mode=display">
\begin{aligned} \hat { x } _ { x } & = \left[ \begin{array} { c c } 1 & \Delta t \\ 0 & 1 \end{array} \right] \hat { x } _ { k - 1 } + \left[ \begin{array} { c } \frac { \Delta t ^ { 2 } } { 2 } \\ \Delta t \end{array} \right] \cdot a \\ & = F _ { k } \hat { x } _ { k - 1 } + B _ { k } \vec { u } _ { k } \end{aligned}</script><p>其中，$ B _ k $ 是控制矩阵，$ \vec { u } _ { k } $ 是控制向量。</p>
<p>&emsp;&emsp;同样，噪声也会存在不确定性，即存在方差，记作 $ Q _ k $ (噪声 $ w _ k \sim N(0, Q _ k) $)，最终有</p>
<script type="math/tex; mode=display">
\left\{ \begin{array} { l } \hat { x } _ { k } = F _ { k } \hat { x } _ { k - 1 } + B _ { k } \vec { u } _ { k } \\ P _ { k } = F _ { k } P _ { k - 1 } F _ { k } ^ { T } + Q _ { k } \end{array} \right.</script><ul>
<li>新的最佳估计是基于<strong>原最佳估计</strong>和<strong>已知外部影响</strong>校正后得到的预测</li>
<li>新的不确定性是基于<strong>原不确定性</strong>和<strong>外部环境的不确定性</strong>得到的预测</li>
</ul>
<h2 id="1-3、-实际应用"><a href="#1-3、-实际应用" class="headerlink" title="1.3、 实际应用"></a>1.3、 实际应用</h2><p>&emsp;&emsp;使用传感器实际测量时会存在一个转换矩阵 $ H _ k $，预测结果为</p>
<script type="math/tex; mode=display">
\begin{aligned}
\vec{\mu} _ {\text {expected }} &=\mathbf{H} _ {k} \hat{\mathbf{x}}_{k} \\
\mathbf{\Sigma} _ {\text {expected }} &=\mathbf{H} _ {k} \mathbf{P}_{k} \mathbf {H} _ {k}^{T}
\end{aligned}</script><p>同时，传感器也存在读数结果，同样存在噪声，均值为 $ z _ k $，协方差为 $ R _ k $。</p>
<p>&emsp;&emsp;所以我们可以得到两个高斯分布数据，一个是预测值 $ X _ {predected} $，一个是测量值 $ Y _ {measurement} $。</p>
<script type="math/tex; mode=display">
X _ {predected} \sim N ( H _ k \hat x _ k , H _ k P _ k H _ k ^ T )
\\
Y _ {measurement} \sim N ( z _ k , R _ k )</script><p><img src="/2020/10/22/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/figure1.jpg" alt></p>
]]></content>
      <categories>
        <category>科研</category>
        <category>大四学习</category>
      </categories>
      <tags>
        <tag>matlab</tag>
        <tag>目标检测跟踪</tag>
        <tag>恒虚检测</tag>
        <tag>卡尔曼滤波</tag>
      </tags>
  </entry>
</search>
