<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>leetcode算法(一)</title>
    <url>/2020/09/18/leetcode%E7%AE%97%E6%B3%95-%E4%B8%80/</url>
    <content><![CDATA[<h1 id="剑指offer03：数组中重复的数字"><a href="#剑指offer03：数组中重复的数字" class="headerlink" title="剑指offer03：数组中重复的数字"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/" target="_blank" rel="noopener">剑指offer03：数组中重复的数字</a></h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在一个长度为 n 的数组 nums 里的所有数字都在 <strong>0～n-1</strong> 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p>
<p>限制 : 2 &lt;= n &lt;= 100000</p>
<a id="more"></a>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ol>
<li><p>数组中一定有元素重复，但重复元素个数不知，重复次数不知。由于输出任意一个重复数字即可，故可排序后比较相邻元素。</p>
</li>
<li><p><strong>遗漏信息</strong> ： 数组长度为 n ,数组中的元素均不大于 n。故可以使用哈希表判断。</p>
</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><ol>
<li>排序后比较相邻元素</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findRepeatNumber</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        nums.sort() <span class="comment"># 排序</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums) - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] != nums[i+<span class="number">1</span>]: <span class="comment"># 如果与之后元素不同</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> nums[i]</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(nlogn)，主要开销于数组排序时间<br>空间复杂度：O(1)</p>
<ol start="2">
<li>哈希表(使用set表示)</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findRepeatNumber</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        dic = set()</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums: <span class="comment"># 遍历每个元素</span></span><br><span class="line">            <span class="keyword">if</span> num <span class="keyword">in</span> dic: <span class="comment"># 如果当前元素在哈希表中出现过则有重复</span></span><br><span class="line">                <span class="keyword">return</span> num</span><br><span class="line">            dic.add(num)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)，遍历数组<br>空间复杂度：O(n)，哈希表空间</p>
<h2 id="题解优化"><a href="#题解优化" class="headerlink" title="题解优化"></a>题解优化</h2><p>原地置换</p>
<p>如果没有重复数字，那么正常排序后，数字 i 应该在下标为 i 的位置，所以思路是重头扫描数组，遇到下标为 i 的数字如果不是 i 的话，(假设为 m ),那么我们就拿与下标 m 的数字交换。在交换过程中，如果有重复的数字发生，那么终止返回 ture</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findRepeatNumber</span><span class="params">(self, nums: [int])</span> -&gt; int:</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(nums):</span><br><span class="line">            <span class="keyword">if</span> nums[i] == i:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> nums[nums[i]] == nums[i]: <span class="keyword">return</span> nums[i]</span><br><span class="line">            nums[nums[i]], nums[i] = nums[i], nums[nums[i]]</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode算法(二)</title>
    <url>/2020/09/20/leetcode%E7%AE%97%E6%B3%95-%E4%BA%8C/</url>
    <content><![CDATA[<h1 id="剑指offer04：二维数组中的查找"><a href="#剑指offer04：二维数组中的查找" class="headerlink" title="剑指offer04：二维数组中的查找"></a><a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/" target="_blank" rel="noopener">剑指offer04：二维数组中的查找</a></h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在一个 n * m 的二维数组中，每一行都按照<strong>从左到右递增</strong>的顺序排序，每一列都按照<strong>从上到下递增</strong>的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<p>限制：<br>0 &lt;= n &lt;= 1000<br>0 &lt;= m &lt;= 1000</p>
<a id="more"></a>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ol>
<li><p>由于 n , m 取值范围在 1000 以内，所以可以考虑枚举法，依次循环查找。</p>
</li>
<li><p>从右上角看( matrix[0][m - 1] )来看，是二叉搜索树(左子树均比父节点小，右子树均比父节点大)。所以遇到比当前位置大的数即向下搜索( j + 1 )，如遇比当前位置小的数即向左搜索( i - 1 )</p>
</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findNumberIn2DArray</span><span class="params">(self, matrix: List[List[int]], target: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> matrix <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> len(matrix) == <span class="number">0</span> <span class="keyword">or</span> len(matrix[<span class="number">0</span>]) == <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 注意 None, [], [[]] 三种特殊情况</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        n = len(matrix)</span><br><span class="line">        m = len(matrix[<span class="number">0</span>])</span><br><span class="line">        i, j = <span class="number">0</span>, m<span class="number">-1</span></span><br><span class="line">        <span class="keyword">if</span> target &lt; matrix[<span class="number">0</span>][<span class="number">0</span>] <span class="keyword">or</span> target &gt; matrix[n<span class="number">-1</span>][m<span class="number">-1</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; n <span class="keyword">and</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> matrix[i][j] == target:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> matrix[i][j] &gt; target:</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode算法(三)</title>
    <url>/2020/10/12/leetcode%E7%AE%97%E6%B3%95-%E4%B8%89/</url>
    <content><![CDATA[<h1 id="LeetCode141：环形链表"><a href="#LeetCode141：环形链表" class="headerlink" title="LeetCode141：环形链表"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">LeetCode141：环形链表</a></h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>给定一个链表，判断链表中是否有环。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p>
<p>如果链表中存在环，则返回 true 。 否则，返回 false 。</p>
<p>提示：</p>
<ul>
<li>链表中节点的数目范围是 $[0, 10^4]$</li>
<li>$-10^5$ &lt;= Node.val &lt;= $10^5$</li>
<li>pos 为 -1 或者链表中的一个 有效索引 。<a id="more"></a>
</li>
</ul>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>本问题是判断链表是否有环，这对应两种情况，即有环与无环，故存在三种结题思路：</p>
<ol>
<li><strong>暴力枚举法</strong> : 由于结点数目有限，所以可以使用枚举法，依次遍历，直到遇到 null 返回 false ，或循环 $10^4$ 次后输出 true。</li>
<li><strong>哈希表</strong> : 该方法是暴力法的优化，使用哈希表记录每个遍历的结点，当遇到重复结点时返回 true ，遍历到 null 时返回 false。</li>
<li><strong>快慢指针</strong> : 使用两个指针，分为快指针和慢指针，其中快指针每次前进两格，即  <code>fast = fast.next.next</code> ，慢指针每次前进一格 <code>slow = slow.next</code> ，若链表有环则快慢指针必然会相遇。否则，快指针会先达到 null 。</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span><span class="params">(self, head: ListNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> head.next <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        fast = head.next</span><br><span class="line">        slow = head</span><br><span class="line">        <span class="keyword">while</span> fast != slow:</span><br><span class="line">            <span class="keyword">if</span> fast.next <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> fast.next.next <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            fast = fast.next.next</span><br><span class="line">            slow = slow.next</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode算法(四)</title>
    <url>/2020/10/12/leetcode%E7%AE%97%E6%B3%95-%E5%9B%9B/</url>
    <content><![CDATA[<h1 id="LeetCode142：环形链表Ⅱ"><a href="#LeetCode142：环形链表Ⅱ" class="headerlink" title="LeetCode142：环形链表Ⅱ"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">LeetCode142：环形链表Ⅱ</a></h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>&emsp;&emsp;给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>
<p>&emsp;&emsp;为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。</p>
<p>提示：</p>
<ul>
<li>链表中节点的数目范围是 $[0, 10^4]$</li>
<li>$-10^5$ &lt;= Node.val &lt;= $10^5$</li>
<li>pos 为 -1 或者链表中的一个 有效索引 。<a id="more"></a>
</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>&emsp;&emsp;与上题<a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">141环形链表类似</a>，但是又有所不同，上题中只需判断是否有环即可，而在本题中需要输出第一个环所在的位置。</p>
<ol>
<li><strong>哈希表</strong> : 使用哈希表记录遍历的每一个结点，当遇到<strong>第一个重复</strong>的结点时，就是环开始的结点位置，将其输出即可。</li>
<li><strong>快慢指针</strong> : 使用两个指针，快指针每次前进两格 <code>fast = fast.next.next</code> , 慢指针每次前进一格 <code>slow = slow.next</code> , 当两指针相遇时，再定义一个指针 ptr 开始从表头开始遍历，当 ptr 与慢指针 slow 相遇时，即是目标结点。</li>
</ol>
<p><img src="/2020/10/12/leetcode%E7%AE%97%E6%B3%95-%E5%9B%9B/142_fig1.png" alt></p>
<p>&emsp;&emsp;如上图所示，其中 a 为链表中非环长度， b 为快慢指针相遇时已走过的环形长度，c 为未走过的距离。所以快指针走过距离为：</p>
<script type="math/tex; mode=display">l_f = a + b + n * (b + c)</script><p>其中，n 为正整数，即相遇时走过的圈数。<br>慢指针走过距离：</p>
<script type="math/tex; mode=display">l_s = a + b</script><p>又由于快指针走过距离为慢指针的两倍，所以有</p>
<script type="math/tex; mode=display">l_f = 2 * l_s --> a = c + (n - 1) * (b + c)</script><p>所以，当快慢指针相遇时，只需再建一个指针指向 head ，与慢指针 slow 同时向前遍历，当相遇时，慢指针 slow 刚好走过 n 圈（快慢指针相遇时，慢指针只走过距离 b ），故二者将在环结点处相遇。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>哈希表<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detectCycle</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        dic = set()</span><br><span class="line">        node = head</span><br><span class="line">        <span class="keyword">while</span> node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">in</span> dic:</span><br><span class="line">                <span class="keyword">return</span> node</span><br><span class="line">            dic.add(node)</span><br><span class="line">            node = node.next</span><br><span class="line">        <span class="keyword">return</span></span><br></pre></td></tr></table></figure></p>
<p>快慢指针<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detectCycle</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> head.next <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        ptr, fast, slow = head, head.next.next, head.next</span><br><span class="line">        <span class="keyword">while</span> fast != slow:</span><br><span class="line">            <span class="keyword">if</span> fast <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> fast.next <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            fast = fast.next.next</span><br><span class="line">            slow = slow.next</span><br><span class="line">        <span class="keyword">while</span> ptr != slow:</span><br><span class="line">            slow = slow.next</span><br><span class="line">            ptr = ptr.next</span><br><span class="line">        <span class="keyword">return</span> ptr</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
</search>
